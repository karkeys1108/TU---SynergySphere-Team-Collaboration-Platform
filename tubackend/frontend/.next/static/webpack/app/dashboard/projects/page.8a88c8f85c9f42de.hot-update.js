"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/projects/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiClient: function() { return /* binding */ apiClient; }\n/* harmony export */ });\nconst API_BASE_URL = \"http://localhost:5000/api\" || 0;\nclass ApiClient {\n    initializeToken() {\n        if (true) {\n            this.token = localStorage.getItem(\"token\");\n        }\n    }\n    setToken(token) {\n        this.token = token;\n        if (true) {\n            localStorage.setItem(\"token\", token);\n        }\n    }\n    removeToken() {\n        this.token = null;\n        if (true) {\n            localStorage.removeItem(\"token\");\n        }\n    }\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        // Ensure token is up to date\n        this.initializeToken();\n        const url = \"\".concat(this.baseURL).concat(endpoint);\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            ...options.headers\n        };\n        // Add auth header if token exists\n        if (this.token) {\n            headers[\"Authorization\"] = \"Bearer \".concat(this.token);\n        }\n        try {\n            const response = await fetch(url, {\n                ...options,\n                headers,\n                credentials: \"include\"\n            });\n            // Handle 401 Unauthorized\n            if (response.status === 401) {\n                this.removeToken();\n                window.location.href = \"/auth/login\";\n                return {\n                    success: false,\n                    error: \"Session expired. Please log in again.\"\n                };\n            }\n            const data = await response.json().catch(()=>({}));\n            if (!response.ok) {\n                return {\n                    success: false,\n                    error: data.message || \"An error occurred\",\n                    ...data\n                };\n            }\n            return {\n                success: true,\n                data,\n                ...data\n            };\n        } catch (error) {\n            console.error(\"API Request Error:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Network error\"\n            };\n        }\n    }\n    // Auth endpoints\n    async login(email, password) {\n        var _response_data;\n        const response = await this.request(\"/auth/login\", {\n            method: \"POST\",\n            body: JSON.stringify({\n                email,\n                password\n            })\n        });\n        if (response.success && ((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.token)) {\n            this.setToken(response.data.token);\n        }\n        return response;\n    }\n    async register(userData) {\n        var _response_data;\n        const response = await this.request(\"/auth/register\", {\n            method: \"POST\",\n            body: JSON.stringify(userData)\n        });\n        if (response.success && ((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.token)) {\n            this.setToken(response.data.token);\n        }\n        return response;\n    }\n    async getProfile() {\n        return this.request(\"/auth/profile\");\n    }\n    async updateProfile(userData) {\n        return this.request(\"/auth/profile\", {\n            method: \"PUT\",\n            body: JSON.stringify(userData)\n        });\n    }\n    // Project endpoints\n    async getProjects() {\n        return this.request(\"/projects\");\n    }\n    async createProject(projectData) {\n        if (!projectData || typeof projectData !== \"object\") {\n            throw new Error(\"Invalid project data\");\n        }\n        return this.request(\"/projects\", {\n            method: \"POST\",\n            body: JSON.stringify(projectData)\n        });\n    }\n    async getProject(id) {\n        if (!id) {\n            throw new Error(\"Project ID is required\");\n        }\n        return this.request(\"/projects/\".concat(id));\n    }\n    async updateProject(id, projectData) {\n        if (!id) {\n            throw new Error(\"Project ID is required\");\n        }\n        if (!projectData || typeof projectData !== \"object\") {\n            throw new Error(\"Invalid project data\");\n        }\n        return this.request(\"/projects/\".concat(id), {\n            method: \"PUT\",\n            body: JSON.stringify(projectData)\n        });\n    }\n    async deleteProject(id) {\n        if (!id) {\n            throw new Error(\"Project ID is required\");\n        }\n        return this.request(\"/projects/\".concat(id), {\n            method: \"DELETE\"\n        });\n    }\n    // Task endpoints\n    async getTasks(projectId) {\n        const endpoint = projectId ? \"/tasks?project=\".concat(projectId) : \"/tasks\";\n        return this.request(endpoint);\n    }\n    async createTask(taskData) {\n        return this.request(\"/tasks\", {\n            method: \"POST\",\n            body: JSON.stringify(taskData)\n        });\n    }\n    async updateTask(id, taskData) {\n        return this.request(\"/tasks/\".concat(id), {\n            method: \"PUT\",\n            body: JSON.stringify(taskData)\n        });\n    }\n    async deleteTask(id) {\n        return this.request(\"/tasks/\".concat(id), {\n            method: \"DELETE\"\n        });\n    }\n    // Message endpoints\n    async getMessages(projectId) {\n        return this.request(\"/messages?project=\".concat(projectId));\n    }\n    async sendMessage(messageData) {\n        return this.request(\"/messages\", {\n            method: \"POST\",\n            body: JSON.stringify(messageData)\n        });\n    }\n    async updateMessage(id, messageData) {\n        return this.request(\"/messages/\".concat(id), {\n            method: \"PUT\",\n            body: JSON.stringify(messageData)\n        });\n    }\n    async deleteMessage(id) {\n        return this.request(\"/messages/\".concat(id), {\n            method: \"DELETE\"\n        });\n    }\n    async likeMessage(id) {\n        return this.request(\"/messages/\".concat(id, \"/like\"), {\n            method: \"POST\"\n        });\n    }\n    async pinMessage(id) {\n        return this.request(\"/messages/\".concat(id, \"/pin\"), {\n            method: \"POST\"\n        });\n    }\n    // Notification endpoints\n    async getNotifications() {\n        return this.request(\"/notifications\");\n    }\n    async markNotificationRead(id) {\n        return this.request(\"/notifications/\".concat(id, \"/read\"), {\n            method: \"PUT\"\n        });\n    }\n    constructor(baseURL){\n        this.token = null;\n        this.baseURL = baseURL;\n        this.initializeToken();\n    }\n}\nconst apiClient = new ApiClient(API_BASE_URL);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WixFQUFVLEVBQUVXLFdBQWdCLEVBQUU7UUFDaEQsT0FBTyxJQUFJLENBQUNoRCxPQUFPLENBQU0sYUFBZ0IsT0FBSHFDLEtBQU07WUFDMUNaLFFBQVE7WUFDUkMsTUFBTUMsS0FBS0MsU0FBUyxDQUFDb0I7UUFDdkI7SUFDRjtJQUVBLE1BQU1FLGNBQWNiLEVBQVUsRUFBRTtRQUM5QixPQUFPLElBQUksQ0FBQ3JDLE9BQU8sQ0FBTSxhQUFnQixPQUFIcUMsS0FBTTtZQUMxQ1osUUFBUTtRQUNWO0lBQ0Y7SUFFQSxNQUFNMEIsWUFBWWQsRUFBVSxFQUFFO1FBQzVCLE9BQU8sSUFBSSxDQUFDckMsT0FBTyxDQUFNLGFBQWdCLE9BQUhxQyxJQUFHLFVBQVE7WUFDL0NaLFFBQVE7UUFDVjtJQUNGO0lBRUEsTUFBTTJCLFdBQVdmLEVBQVUsRUFBRTtRQUMzQixPQUFPLElBQUksQ0FBQ3JDLE9BQU8sQ0FBTSxhQUFnQixPQUFIcUMsSUFBRyxTQUFPO1lBQzlDWixRQUFRO1FBQ1Y7SUFDRjtJQUVBLHlCQUF5QjtJQUN6QixNQUFNNEIsbUJBQW1CO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDckQsT0FBTyxDQUFRO0lBQzdCO0lBRUEsTUFBTXNELHFCQUFxQmpCLEVBQVUsRUFBRTtRQUNyQyxPQUFPLElBQUksQ0FBQ3JDLE9BQU8sQ0FBTSxrQkFBcUIsT0FBSHFDLElBQUcsVUFBUTtZQUNwRFosUUFBUTtRQUNWO0lBQ0Y7SUFuUEE4QixZQUFZbkQsT0FBZSxDQUFFO2FBRnJCWCxRQUF1QjtRQUc3QixJQUFJLENBQUNXLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNaLGVBQWU7SUFDdEI7QUFpUEY7QUFFTyxNQUFNZ0UsWUFBWSxJQUFJakUsVUFBVUosY0FBYSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYXBpLnRzPzY4YTEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9hcGlcIlxuXG5pbnRlcmZhY2UgQXBpUmVzcG9uc2U8VCA9IGFueT4ge1xuICBzdWNjZXNzOiBib29sZWFuXG4gIGRhdGE/OiBUXG4gIG1lc3NhZ2U/OiBzdHJpbmdcbiAgZXJyb3I/OiBzdHJpbmdcbn1cblxuY2xhc3MgQXBpQ2xpZW50IHtcbiAgcHJpdmF0ZSBiYXNlVVJMOiBzdHJpbmdcbiAgcHJpdmF0ZSB0b2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcihiYXNlVVJMOiBzdHJpbmcpIHtcbiAgICB0aGlzLmJhc2VVUkwgPSBiYXNlVVJMXG4gICAgdGhpcy5pbml0aWFsaXplVG9rZW4oKVxuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplVG9rZW4oKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlblwiKVxuICAgIH1cbiAgfVxuXG4gIHNldFRva2VuKHRva2VuOiBzdHJpbmcpIHtcbiAgICB0aGlzLnRva2VuID0gdG9rZW5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidG9rZW5cIiwgdG9rZW4pXG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlVG9rZW4oKSB7XG4gICAgdGhpcy50b2tlbiA9IG51bGxcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwidG9rZW5cIilcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlcXVlc3Q8VD4oXG4gICAgZW5kcG9pbnQ6IHN0cmluZywgXG4gICAgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fVxuICApOiBQcm9taXNlPEFwaVJlc3BvbnNlPFQ+PiB7XG4gICAgLy8gRW5zdXJlIHRva2VuIGlzIHVwIHRvIGRhdGVcbiAgICB0aGlzLmluaXRpYWxpemVUb2tlbigpXG4gICAgXG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVVJMfSR7ZW5kcG9pbnR9YFxuICAgIGNvbnN0IGhlYWRlcnM6IEhlYWRlcnNJbml0ID0ge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICB9XG5cbiAgICAvLyBBZGQgYXV0aCBoZWFkZXIgaWYgdG9rZW4gZXhpc3RzXG4gICAgaWYgKHRoaXMudG9rZW4pIHtcbiAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0aGlzLnRva2VufWBcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJywgLy8gSW1wb3J0YW50IGZvciBjb29raWVzIGlmIHVzaW5nIHRoZW1cbiAgICAgIH0pXG5cbiAgICAgIC8vIEhhbmRsZSA0MDEgVW5hdXRob3JpemVkXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVUb2tlbigpXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9hdXRoL2xvZ2luJ1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiAnU2Vzc2lvbiBleHBpcmVkLiBQbGVhc2UgbG9nIGluIGFnYWluLidcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogZGF0YS5tZXNzYWdlIHx8ICdBbiBlcnJvciBvY2N1cnJlZCcsXG4gICAgICAgICAgLi4uZGF0YVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQVBJIFJlcXVlc3QgRXJyb3I6JywgZXJyb3IpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ05ldHdvcmsgZXJyb3InLFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEF1dGggZW5kcG9pbnRzXG4gIGFzeW5jIGxvZ2luKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdDx7IHRva2VuOiBzdHJpbmc7IHVzZXI6IGFueSB9PignL2F1dGgvbG9naW4nLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIHBhc3N3b3JkIH0pLFxuICAgIH0pXG5cbiAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhPy50b2tlbikge1xuICAgICAgdGhpcy5zZXRUb2tlbihyZXNwb25zZS5kYXRhLnRva2VuKVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgYXN5bmMgcmVnaXN0ZXIodXNlckRhdGE6IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBlbWFpbDogc3RyaW5nXG4gICAgcGFzc3dvcmQ6IHN0cmluZ1xuICAgIHJvbGU/OiBzdHJpbmdcbiAgfSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0PHsgdG9rZW46IHN0cmluZzsgdXNlcjogYW55IH0+KCcvYXV0aC9yZWdpc3RlcicsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpLFxuICAgIH0pXG5cbiAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhPy50b2tlbikge1xuICAgICAgdGhpcy5zZXRUb2tlbihyZXNwb25zZS5kYXRhLnRva2VuKVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgYXN5bmMgZ2V0UHJvZmlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PGFueT4oJy9hdXRoL3Byb2ZpbGUnKVxuICB9XG5cbiAgYXN5bmMgdXBkYXRlUHJvZmlsZSh1c2VyRGF0YTogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxhbnk+KCcvYXV0aC9wcm9maWxlJywge1xuICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpLFxuICAgIH0pXG4gIH1cblxuICAvLyBQcm9qZWN0IGVuZHBvaW50c1xuICBhc3luYyBnZXRQcm9qZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PGFueVtdPihcIi9wcm9qZWN0c1wiKVxuICB9XG5cbiAgYXN5bmMgY3JlYXRlUHJvamVjdChwcm9qZWN0RGF0YTogYW55KSB7XG4gICAgaWYgKCFwcm9qZWN0RGF0YSB8fCB0eXBlb2YgcHJvamVjdERhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvamVjdCBkYXRhJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxhbnk+KFwiL3Byb2plY3RzXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwcm9qZWN0RGF0YSksXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGdldFByb2plY3QoaWQ6IHN0cmluZykge1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdCBJRCBpcyByZXF1aXJlZCcpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8YW55PihgL3Byb2plY3RzLyR7aWR9YClcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVByb2plY3QoaWQ6IHN0cmluZywgcHJvamVjdERhdGE6IGFueSkge1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdCBJRCBpcyByZXF1aXJlZCcpXG4gICAgfVxuICAgIGlmICghcHJvamVjdERhdGEgfHwgdHlwZW9mIHByb2plY3REYXRhICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByb2plY3QgZGF0YScpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8YW55PihgL3Byb2plY3RzLyR7aWR9YCwge1xuICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHJvamVjdERhdGEpLFxuICAgIH0pXG4gIH1cblxuICBhc3luYyBkZWxldGVQcm9qZWN0KGlkOiBzdHJpbmcpIHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QgSUQgaXMgcmVxdWlyZWQnKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PGFueT4oYC9wcm9qZWN0cy8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICB9KVxuICB9XG5cbiAgLy8gVGFzayBlbmRwb2ludHNcbiAgYXN5bmMgZ2V0VGFza3MocHJvamVjdElkPzogc3RyaW5nKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSBwcm9qZWN0SWQgPyBgL3Rhc2tzP3Byb2plY3Q9JHtwcm9qZWN0SWR9YCA6IFwiL3Rhc2tzXCJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PGFueVtdPihlbmRwb2ludClcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZVRhc2sodGFza0RhdGE6IGFueSkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8YW55PihcIi90YXNrc1wiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGFza0RhdGEpLFxuICAgIH0pXG4gIH1cblxuICBhc3luYyB1cGRhdGVUYXNrKGlkOiBzdHJpbmcsIHRhc2tEYXRhOiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PGFueT4oYC90YXNrcy8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRhc2tEYXRhKSxcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgZGVsZXRlVGFzayhpZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxhbnk+KGAvdGFza3MvJHtpZH1gLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgfSlcbiAgfVxuXG4gIC8vIE1lc3NhZ2UgZW5kcG9pbnRzXG4gIGFzeW5jIGdldE1lc3NhZ2VzKHByb2plY3RJZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxhbnlbXT4oYC9tZXNzYWdlcz9wcm9qZWN0PSR7cHJvamVjdElkfWApXG4gIH1cblxuICBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlRGF0YTogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxhbnk+KFwiL21lc3NhZ2VzXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtZXNzYWdlRGF0YSksXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZU1lc3NhZ2UoaWQ6IHN0cmluZywgbWVzc2FnZURhdGE6IGFueSkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8YW55PihgL21lc3NhZ2VzLyR7aWR9YCwge1xuICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWVzc2FnZURhdGEpLFxuICAgIH0pXG4gIH1cblxuICBhc3luYyBkZWxldGVNZXNzYWdlKGlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PGFueT4oYC9tZXNzYWdlcy8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgbGlrZU1lc3NhZ2UoaWQ6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8YW55PihgL21lc3NhZ2VzLyR7aWR9L2xpa2VgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIH0pXG4gIH1cblxuICBhc3luYyBwaW5NZXNzYWdlKGlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PGFueT4oYC9tZXNzYWdlcy8ke2lkfS9waW5gLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIH0pXG4gIH1cblxuICAvLyBOb3RpZmljYXRpb24gZW5kcG9pbnRzXG4gIGFzeW5jIGdldE5vdGlmaWNhdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxhbnlbXT4oXCIvbm90aWZpY2F0aW9uc1wiKVxuICB9XG5cbiAgYXN5bmMgbWFya05vdGlmaWNhdGlvblJlYWQoaWQ6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8YW55PihgL25vdGlmaWNhdGlvbnMvJHtpZH0vcmVhZGAsIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBhcGlDbGllbnQgPSBuZXcgQXBpQ2xpZW50KEFQSV9CQVNFX1VSTClcbmV4cG9ydCB0eXBlIHsgQXBpUmVzcG9uc2UgfVxuIl0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiQXBpQ2xpZW50IiwiaW5pdGlhbGl6ZVRva2VuIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0VG9rZW4iLCJzZXRJdGVtIiwicmVtb3ZlVG9rZW4iLCJyZW1vdmVJdGVtIiwicmVxdWVzdCIsImVuZHBvaW50Iiwib3B0aW9ucyIsInVybCIsImJhc2VVUkwiLCJoZWFkZXJzIiwicmVzcG9uc2UiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwic3RhdHVzIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwic3VjY2VzcyIsImVycm9yIiwiZGF0YSIsImpzb24iLCJjYXRjaCIsIm9rIiwibWVzc2FnZSIsImNvbnNvbGUiLCJFcnJvciIsImxvZ2luIiwiZW1haWwiLCJwYXNzd29yZCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicmVnaXN0ZXIiLCJ1c2VyRGF0YSIsImdldFByb2ZpbGUiLCJ1cGRhdGVQcm9maWxlIiwiZ2V0UHJvamVjdHMiLCJjcmVhdGVQcm9qZWN0IiwicHJvamVjdERhdGEiLCJnZXRQcm9qZWN0IiwiaWQiLCJ1cGRhdGVQcm9qZWN0IiwiZGVsZXRlUHJvamVjdCIsImdldFRhc2tzIiwicHJvamVjdElkIiwiY3JlYXRlVGFzayIsInRhc2tEYXRhIiwidXBkYXRlVGFzayIsImRlbGV0ZVRhc2siLCJnZXRNZXNzYWdlcyIsInNlbmRNZXNzYWdlIiwibWVzc2FnZURhdGEiLCJ1cGRhdGVNZXNzYWdlIiwiZGVsZXRlTWVzc2FnZSIsImxpa2VNZXNzYWdlIiwicGluTWVzc2FnZSIsImdldE5vdGlmaWNhdGlvbnMiLCJtYXJrTm90aWZpY2F0aW9uUmVhZCIsImNvbnN0cnVjdG9yIiwiYXBpQ2xpZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});